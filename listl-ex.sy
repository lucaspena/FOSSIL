(set-logic ALL)

;; true models obtained from Z3Py

;; [next = [1 -> 2, 2 -> 1, else -> -1],
;;  list = [else -> Var(0) == -1],
;;  rank-list = [-1 -> 0, else -> -1],
;;  listlen = [else -> And(Var(0) == -1, Var(1) == 0)],
;;  rank-listlen = [(-1, 0) -> 0,
;;                  (-1, 1) -> 0,
;;                  (-1, 2) -> 0,

;; false model obtained from Z3Py
;; [l = 2,
;;  x = 3,
;;  ret = 4,
;;  next = [3 -> 4, 4 -> 5, else -> -1],
;;  list = [else -> Var(0) == -1],
;;  listlen = [else -> True]]

;; x = 3, ret = 4
(declare-const x Int)
(declare-const ret Int)
(assert (= x 3))
(assert (= ret 4))

;; next (combine real and fake)
(define-fun next ((x Int)) Int
  (ite (= x 1) 2
  (ite (= x 2) 1
  (ite (= x 3) 4
  (ite (= x 4) 5
  (- 1)))))
)

;; list (combine real and fake)
(define-fun list ((x Int)) Bool
  (= x (- 1))
)

;; concrete listlen model (combine real and fake)
(define-fun listlen ((x Int) (l Int)) Bool
  (or (and (= x (- 1)) (= l 0))
      (= x 3)
      (= x 4)
      (= x 5)
  )
)

;; lemma to synthesize
(synth-fun lemma ((x Int) (l Int)) Bool

           ((Start Bool) (Rec Bool) (B Bool) (I Int) (L Int))

           ((Start Bool
                  ((=> Rec B)))
           (Rec Bool
                  ((list I) (listlen I L)))
           (B Bool
                  ((=> B B)
                   (and B B)
                   (or B B)
                   (not B)
                   (list I) (listlen I L)))
            (I Int (x (- 1)
                   (next I)))
            (L Int (l
                   (+ L L))))

)

;; constraint from false model
;; not lemma x l OR not lemma ret l
(constraint (exists ((l Int))
            (or (not (lemma x l))
                (not (lemma ret l)))))

;; constraints from true model
;; ideally constraint would look like this, but for now we need to
;; enumerate a small universe of possible l's to make SyGuS happy
;; (constraint (forall ((l Int))
;;             (and (lemma 0 l)
;;                  (lemma 1 l)
;;                  (lemma 2 l)))
(constraint (lemma (- 1) 0))
(constraint (lemma (- 1) 1))
(constraint (lemma (- 1) 2))
(constraint (lemma 1 (- 1)))
(constraint (lemma 1 0))
(constraint (lemma 1 1))
(constraint (lemma 1 2))
(constraint (lemma 2 (- 1)))
(constraint (lemma 2 0))
(constraint (lemma 2 1))
(constraint (lemma 2 2))

(check-synth)