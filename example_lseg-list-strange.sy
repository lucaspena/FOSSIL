;The grammar is the full one. No restrictions
;Commands to run
;This one does not give an answer
;cvc4 --lang=sygus2 --sygus-stream example_lseg-list-strange.sy
;This one gives an answer: 38th on my machine
;cvc4 --lang=sygus2 --sygus-stream example_lseg-list-strange.sy --sygus-active-gen=basic

(set-logic ALL)

;; x = 0, y = 1, z = 2
;(declare-const x Int)
;(declare-const y Int)
;(declare-const z Int)
;(assert (= x 0))
;(assert (= y 1))
;(assert (= z 2))

;; combination of true models and false model
(define-fun next ((x!0 Int)) Int
  (ite (= x!0 8300) 8301
  (ite (= x!0 8301) 8301
  (ite (= x!0 8302) 8300
  (ite (= x!0 6600) 6600
  (ite (= x!0 6601) 6601
  (ite (= x!0 6602) 6602
  (ite (= x!0 16050) 16051
  (ite (= x!0 16051) 16051
  (ite (= x!0 16052) 16052
  (ite (= x!0 4000) 4000
  (ite (= x!0 4001) 4002
  (ite (= x!0 4002) 4001
  (ite (= x!0 400) 402
  (ite (= x!0 401) 401
  (ite (= x!0 402) 401
  (ite (= x!0 1000) 1000
  (ite (= x!0 1001) 1001
  (ite (= x!0 1002) 1001
  (ite (= x!0 6700) 6700
  (ite (= x!0 6701) 6702
  (ite (= x!0 6702) 6701
  (ite (= x!0 7450) 7450
  (ite (= x!0 7451) 7451
  (ite (= x!0 7452) 7451
  (ite (= x!0 20600) 20602
  (ite (= x!0 20601) 20600
  (ite (= x!0 20602) 20602
  (ite (= x!0 1) 1
  (ite (= x!0 0) 1
  (ite (= x!0 2) 4
    7250)))))))))))))))))))))))))))))))
(define-fun list ((x!0 Int)) Bool
  (ite (= x!0 6601) false
  (ite (= x!0 6602) false
  (ite (= x!0 16052) false
  (ite (= x!0 4001) false
  (ite (= x!0 4002) false
  (ite (= x!0 1000) false
  (ite (= x!0 6701) false
  (ite (= x!0 6702) false
  (ite (= x!0 7451) false
  (ite (= x!0 7452) false
  (ite (= x!0 2) false
    true))))))))))))
(define-fun lsegy ((x!0 Int)) Bool
  (or (= x!0 0)
      (= x!0 8300)
      (= x!0 8302)
      (= x!0 7252)
      (= x!0 6602)
      (= x!0 16052)
      (= x!0 4001)
      (= x!0 4002)
      (= x!0 400)
      (= x!0 1000)
      (= x!0 6701)
      (= x!0 6702)
      (= x!0 7452)
      (= x!0 20601)))
(define-fun list_p ((x!0 Int)) Bool
  (ite (= x!0 8300) false
  (ite (= x!0 8302) false
  (ite (= x!0 7252) false
  (ite (= x!0 6601) false
  (ite (= x!0 6602) false
  (ite (= x!0 16052) false
  (ite (= x!0 4001) false
  (ite (= x!0 4002) false
  (ite (= x!0 400) false
  (ite (= x!0 6701) false
  (ite (= x!0 6702) false
  (ite (= x!0 7451) false
  (ite (= x!0 7452) false
  (ite (= x!0 20601) false
  (ite (= x!0 2) false
    true))))))))))))))))
(define-fun next_p ((x!0 Int)) Int
  (ite (= x!0 8300) 8300
  (ite (= x!0 8301) 8301
  (ite (= x!0 8302) 8300
  (ite (= x!0 7250) 7250
  (ite (= x!0 7251) 7250
  (ite (= x!0 7252) 7252
  (ite (= x!0 6600) 6600
  (ite (= x!0 6601) 6601
  (ite (= x!0 6602) 6601
  (ite (= x!0 16050) 16051
  (ite (= x!0 16051) 16051
  (ite (= x!0 16052) 16052
  (ite (= x!0 4000) 4000
  (ite (= x!0 4001) 4001
  (ite (= x!0 4002) 4001
  (ite (= x!0 400) 400
  (ite (= x!0 401) 401
  (ite (= x!0 402) 401
  (ite (= x!0 6700) 6700
  (ite (= x!0 6701) 6702
  (ite (= x!0 6702) 6701
  (ite (= x!0 7450) 7450
  (ite (= x!0 7451) 7451
  (ite (= x!0 7452) 7452
  (ite (= x!0 20600) 20602
  (ite (= x!0 20601) 20601
  (ite (= x!0 20602) 20602
  (ite (= x!0 1) 1
  (ite (= x!0 0) 3
  (ite (= x!0 2) 4
    1001)))))))))))))))))))))))))))))))
(define-fun lsegy_p ((x!0 Int)) Bool
  (or (= x!0 2)
      (= x!0 0)
      (= x!0 8300)
      (= x!0 8302)
      (= x!0 7252)
      (= x!0 6602)
      (= x!0 16052)
      (= x!0 4001)
      (= x!0 4002)
      (= x!0 400)
      (= x!0 1000)
      (= x!0 6701)
      (= x!0 6702)
      (= x!0 7452)
      (= x!0 20601)))

;; TODO: this should be generated from the problem parameters
;; lemma to synthesize
(synth-fun lemma ((x Int) (nil Int) (y Int)) Bool
           ((Start Bool) (Rec Bool) (B Bool) (I Int))

           ((Start Bool
                  ((=> Rec B)))
           (Rec Bool
                  ((list I) (lsegy I) (list_p I) (lsegy_p I)))
           (B Bool
                  ((=> B B)
                   (and B B)
                   (or B B)
                   (not B)
                   (list I) (lsegy I) (list_p I) (lsegy_p I)))
            (I Int (x nil y
                   (next I)
                   )))
)


;; Grammar for old version of code. Must be removed
;(synth-fun lemma ((x Int)) Bool
;           ((Start Bool) (Rec Bool) (B Bool) (I Int))
;
;           ((Start Bool
;                  ((=> Rec B)))
;           (Rec Bool
;                  ((list I) (lsegy I) (list_p I) (lsegy_p I)))
;           (B Bool
;                  ((=> B B)
;                   (and B B)
;                   (or B B)
;                   (not B)
;                   (list I) (lsegy I) (list_p I) (lsegy_p I)))
;            (I Int (x nil y
;                   (next I))))
;)
;; constraints from false model
(constraint (or (not (lemma 1 1 0))
(not (lemma 0 1 0))
(not (lemma 2 1 0))
(not (lemma 0 1 0))
))

;; constraints from true models
(constraint (and (lemma 8300 8301 8300)
(lemma 8301 8301 8300)
(lemma 8302 8301 8300)
))
(constraint (and (lemma 7250 7250 7252)
(lemma 7251 7250 7252)
(lemma 7252 7250 7252)
))
(constraint (and (lemma 6600 6600 6602)
(lemma 6601 6600 6602)
(lemma 6602 6600 6602)
))
(constraint (and (lemma 16050 16051 16052)
(lemma 16051 16051 16052)
(lemma 16052 16051 16052)
))
(constraint (and (lemma 4000 4000 4001)
(lemma 4001 4000 4001)
(lemma 4002 4000 4001)
))
(constraint (and (lemma 400 401 400)
(lemma 401 401 400)
(lemma 402 401 400)
))
(constraint (and (lemma 1000 1001 1000)
(lemma 1001 1001 1000)
(lemma 1002 1001 1000)
))
(constraint (and (lemma 6700 6700 6702)
(lemma 6701 6700 6702)
(lemma 6702 6700 6702)
))
(constraint (and (lemma 7450 7450 7452)
(lemma 7451 7450 7452)
(lemma 7452 7450 7452)
))
(constraint (and (lemma 20600 20602 20601)
(lemma 20601 20602 20601)
(lemma 20602 20602 20601)
))

(check-synth)