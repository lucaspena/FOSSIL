(set-logic ALL)

;; x = 0, y = 1, z = 2
;(declare-const x Int)
;(declare-const y Int)
;(declare-const z Int)
;(assert (= x 0))
;(assert (= y 1))
;(assert (= z 2))

;; combination of true models and false model
(define-fun next ((x!0 Int)) Int
  (ite (= x!0 23800) 23800
  (ite (= x!0 23801) 23802
  (ite (= x!0 23802) 23801
  (ite (= x!0 15250) 15252
  (ite (= x!0 15251) 15251
  (ite (= x!0 15252) 15251
  (ite (= x!0 11600) 11602
  (ite (= x!0 11601) 11600
  (ite (= x!0 11602) 11602
  (ite (= x!0 10000) 10000
  (ite (= x!0 10001) 10001
  (ite (= x!0 10002) 10001
  (ite (= x!0 11150) 11150
  (ite (= x!0 11151) 11152
  (ite (= x!0 11152) 11150
  (ite (= x!0 12250) 12250
  (ite (= x!0 12251) 12251
  (ite (= x!0 12252) 12252
  (ite (= x!0 21050) 21050
  (ite (= x!0 21051) 21052
  (ite (= x!0 21052) 21050
  (ite (= x!0 16200) 16202
  (ite (= x!0 16201) 16201
  (ite (= x!0 16202) 16202
  (ite (= x!0 2850) 2850
  (ite (= x!0 2851) 2850
  (ite (= x!0 2852) 2852
  (ite (= x!0 1) 1
  (ite (= x!0 0) 1
  (ite (= x!0 2) 4
  (ite (= x!0 4) 5
    19802))))))))))))))))))))))))))))))))
(define-fun list ((x!0 Int)) Bool
  (ite (= x!0 23801) false
  (ite (= x!0 23802) false
  (ite (= x!0 10000) false
  (ite (= x!0 12250) false
  (ite (= x!0 12251) false
  (ite (= x!0 16200) false
  (ite (= x!0 16202) false
  (ite (= x!0 2852) false
  (ite (= x!0 2) false
  (ite (= x!0 4) false
    true)))))))))))
(define-fun lsegy ((x!0 Int)) Bool
  (or (= x!0 4)
      (= x!0 2)
      (= x!0 0)
      (= x!0 23801)
      (= x!0 23802)
      (= x!0 15250)
      (= x!0 15252)
      (= x!0 11601)
      (= x!0 10000)
      (= x!0 11151)
      (= x!0 12251)
      (= x!0 21051)
      (= x!0 16200)
      (= x!0 16202)
      (= x!0 2851)
      (= x!0 19801)))
(define-fun list_p ((x!0 Int)) Bool
  (ite (= x!0 23801) false
  (ite (= x!0 23802) false
  (ite (= x!0 12250) false
  (ite (= x!0 12251) false
  (ite (= x!0 16200) false
  (ite (= x!0 16202) false
  (ite (= x!0 2852) false
  (ite (= x!0 0) false
  (ite (= x!0 2) false
  (ite (= x!0 4) false
    true)))))))))))
(define-fun next_p ((x!0 Int)) Int
  (ite (= x!0 23800) 23800
  (ite (= x!0 23801) 23802
  (ite (= x!0 23802) 23802
  (ite (= x!0 15250) 15252
  (ite (= x!0 15251) 15251
  (ite (= x!0 15252) 15251
  (ite (= x!0 11600) 11602
  (ite (= x!0 11601) 11600
  (ite (= x!0 11602) 11602
  (ite (= x!0 10000) 10002
  (ite (= x!0 10001) 10001
  (ite (= x!0 10002) 10001
  (ite (= x!0 12250) 12250
  (ite (= x!0 12251) 12251
  (ite (= x!0 12252) 12252
  (ite (= x!0 21050) 21050
  (ite (= x!0 21051) 21052
  (ite (= x!0 21052) 21050
  (ite (= x!0 16200) 16202
  (ite (= x!0 16201) 16201
  (ite (= x!0 16202) 16202
  (ite (= x!0 2850) 2850
  (ite (= x!0 2851) 2850
  (ite (= x!0 2852) 2852
  (ite (= x!0 19800) 19802
  (ite (= x!0 19801) 19800
  (ite (= x!0 19802) 19802
  (ite (= x!0 1) 1
  (ite (= x!0 0) 3
  (ite (= x!0 2) 4
  (ite (= x!0 4) 5
    11150))))))))))))))))))))))))))))))))
(define-fun lsegy_p ((x!0 Int)) Bool
  (or (= x!0 0)
      (= x!0 23801)
      (= x!0 23802)
      (= x!0 15250)
      (= x!0 15252)
      (= x!0 11601)
      (= x!0 10000)
      (= x!0 11151)
      (= x!0 12251)
      (= x!0 21051)
      (= x!0 16200)
      (= x!0 16202)
      (= x!0 2851)
      (= x!0 19801)))

;; TODO: this should be generated from the problem parameters
;; lemma to synthesize
(synth-fun lemma ((x Int) (nil Int) (y Int)) Bool
           ((Start Bool) (Rec Bool) (B Bool) (I Int))

           ((Start Bool
                  ((=> Rec B)))
           (Rec Bool
                  ((list I) (lsegy I) (list_p I) (lsegy_p I)))
           (B Bool
                  ((=> B B)
                   (and B B)
                   (or B B)
                   (not B)
                   (list I) (lsegy I) (list_p I) (lsegy_p I)))
            (I Int (x nil y
                   (next I))))
)

;; constraints from false model
(constraint (or (not (lemma 1 1 0))
(not (lemma 0 1 0))
(not (lemma 2 1 0))
(not (lemma 4 1 0))
))

;; constraints from true models
(constraint (or (lemma 23800 23800 23802)
(lemma 23801 23800 23802)
(lemma 23802 23800 23802)
))
(constraint (or (lemma 15250 15251 15252)
(lemma 15251 15251 15252)
(lemma 15252 15251 15252)
))
(constraint (or (lemma 11600 11602 11601)
(lemma 11601 11602 11601)
(lemma 11602 11602 11601)
))
(constraint (or (lemma 10000 10001 10000)
(lemma 10001 10001 10000)
(lemma 10002 10001 10000)
))
(constraint (or (lemma 11150 11150 11151)
(lemma 11151 11150 11151)
(lemma 11152 11150 11151)
))
(constraint (or (lemma 12250 12252 12251)
(lemma 12251 12252 12251)
(lemma 12252 12252 12251)
))
(constraint (or (lemma 21050 21050 21051)
(lemma 21051 21050 21051)
(lemma 21052 21050 21051)
))
(constraint (or (lemma 16200 16201 16202)
(lemma 16201 16201 16202)
(lemma 16202 16201 16202)
))
(constraint (or (lemma 2850 2850 2851)
(lemma 2851 2850 2851)
(lemma 2852 2850 2851)
))
(constraint (or (lemma 19800 19802 19801)
(lemma 19801 19802 19801)
(lemma 19802 19802 19801)
))

(check-synth)